<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>501st Clone Trooper 3D Viewer</title>
    <style>
        body { margin: 0; background: #0a0a0a; color: white; font-family: Arial; }
        #container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        .ui {
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7);
            padding: 15px; border-radius: 10px; min-width: 200px;
        }
        h3 { margin: 0 0 10px 0; color: #4a9eff; }
        button {
            padding: 10px 15px; margin: 5px; background: #1e3a8a;
            color: white; border: none; border-radius: 5px; cursor: pointer;
            width: 100%;
        }
        button:hover { background: #2563eb; }
        .active { background: #3b82f6; }
        .sequence { background: #10b981; }
        .sequence:hover { background: #34d399; }
        .status {
            margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1);
            border-radius: 5px; font-size: 14px;
        }
        .progress { 
            width: 100%; height: 5px; background: #333; margin-top: 5px;
            border-radius: 3px; overflow: hidden;
        }
        .progress-bar {
            height: 100%; background: #3b82f6; width: 0%;
            transition: width 0.3s;
        }
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #4a9eff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div class="loading" id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ 3D –º–æ–¥–µ–ª–∏...</div>
        <div class="ui" id="ui" style="display: none;">
            <h3>501st Clone Trooper</h3>
            <button class="sequence" onclick="playSequence()">‚ñ∂ –í—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å</button>
            <button onclick="stopAll()">‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
            <div id="anim-buttons"></div>
            <div class="status">
                –¢–µ–∫—É—â–∞—è: <span id="current">Idle</span><br>
                –°—Ç–∞—Ç—É—Å: <span id="status">–û–∂–∏–¥–∞–Ω–∏–µ</span>
                <div class="progress"><div class="progress-bar" id="progress-bar"></div></div>
            </div>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        const ANIMATIONS = ['Idle', 'Up', 'Fire', 'Down', 'Death'];
        let scene, camera, renderer, controls, mixer, model;
        let currentAnim = 0;
        let isPlaying = false;
        let clock = new THREE.Clock();
        let progressTimer = null;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        function init() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // –ö–∞–º–µ—Ä–∞
            const canvas = document.getElementById('canvas');
            camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(3, 2, 5);
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            // –ö–æ–Ω—Ç—Ä–æ–ª—ã
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 20;
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            light.shadow.mapSize.width = 2048;
            light.shadow.mapSize.height = 2048;
            light.shadow.camera.left = -20;
            light.shadow.camera.right = 20;
            light.shadow.camera.top = 20;
            light.shadow.camera.bottom = -20;
            scene.add(light);
            
            // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
            const fillLight = new THREE.DirectionalLight(0x4466ff, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // –ü–æ–ª
            const floorGeometry = new THREE.CircleGeometry(10, 32);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°–µ—Ç–∫–∞ –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            gridHelper.position.y = -0.99;
            scene.add(gridHelper);
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
            loadModel();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫
            createButtons();
            
            // –ê–Ω–∏–º–∞—Ü–∏—è
            animate();
            
            // –†–µ—Å–∞–π–∑
            window.addEventListener('resize', onWindowResize);
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
        function loadModel() {
            const loader = new THREE.FBXLoader();
            const modelPath = 'Models/Phase II Clone Trooper_posed.fbx';
            
            console.log('üîÑ –ó–∞–≥—Ä—É–∂–∞—é –º–æ–¥–µ–ª—å:', modelPath);
            
            loader.load(modelPath,
                // –£—Å–ø–µ—à–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
                (fbx) => {
                    console.log('‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
                    
                    model = fbx;
                    
                    // –ú–∞—Å—à—Ç–∞–± –¥–ª—è .fbx —Ñ–∞–π–ª–æ–≤
                    model.scale.set(0.01, 0.01, 0.01);
                    
                    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º
                    model.position.y = 0;
                    
                    // –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—É—Ç–∏ –∫ —Ç–µ–∫—Å—Ç—É—Ä–∞–º (–í–°–ï —Ç–µ–∫—Å—Ç—É—Ä—ã –ª–µ–∂–∞—Ç –ø—Ä—è–º–æ –≤ Models/)
                    fixTexturePaths(model);
                    
                    // –í–∫–ª—é—á–∞–µ–º —Ç–µ–Ω–∏ –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è PBR
                            if (child.material) {
                                child.material.envMapIntensity = 1.0;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –º–æ–¥–µ–ª—å –Ω–∞ —Å—Ü–µ–Ω—É
                    scene.add(model);
                    
                    // –°–æ–∑–¥–∞–µ–º –º–∏–∫—Å–µ—Ä –∞–Ω–∏–º–∞—Ü–∏–π
                    mixer = new THREE.AnimationMixer(model);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                    if (fbx.animations && fbx.animations.length > 0) {
                        console.log('üì¶ –í –º–æ–¥–µ–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –∞–Ω–∏–º–∞—Ü–∏–π:', fbx.animations.length);
                        // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–º–µ—Å—Ç–æ –∑–∞–≥—Ä—É–∑–∫–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                    }
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑—á–∏–∫ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º UI
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('ui').style.display = 'block';
                    
                    // –§–æ–∫—É—Å–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –Ω–∞ –º–æ–¥–µ–ª–∏
                    camera.lookAt(model.position);
                    
                    console.log('üéÆ –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞ –∫ –∞–Ω–∏–º–∞—Ü–∏—è–º!');
                },
                // –ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏
                (xhr) => {
                    if (xhr.lengthComputable) {
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        console.log(`üì• –ó–∞–≥—Ä—É–∂–µ–Ω–æ: ${percent}%`);
                        document.getElementById('loading').textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏... ${percent}%`;
                    }
                },
                // –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏
                (error) => {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
                    createMockModel();
                }
            );
        }

        // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É—Ç–µ–π –∫ —Ç–µ–∫—Å—Ç—É—Ä–∞–º (–≤—Å–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ª–µ–∂–∞—Ç –ø—Ä—è–º–æ –≤ Models/)
        function fixTexturePaths(model) {
            const textureManager = new THREE.TextureLoader();
            
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const material = child.material;
                    
                    // –°–ø–∏—Å–æ–∫ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä–Ω—ã—Ö –∫–∞—Ä—Ç
                    const textureMaps = [
                        'map',           // albedo/diffuse
                        'normalMap',     // normal
                        'metalnessMap',  // metallic
                        'roughnessMap',  // roughness
                        'aoMap',         // ambient occlusion
                        'emissiveMap',   // emission
                        'alphaMap',      // alpha
                        'displacementMap' // displacement
                    ];
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–∞—Ä—Ç—ã
                    textureMaps.forEach(mapType => {
                        if (material[mapType]) {
                            try {
                                // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –æ–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç—å
                                const tex = material[mapType];
                                if (tex.image && tex.image.currentSrc) {
                                    // –£–±–∏—Ä–∞–µ–º –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ textures/
                                    const filename = tex.image.currentSrc.split('/').pop();
                                    tex.sourceFile = filename;
                                }
                            } catch (e) {
                                console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø—Ä–∞–≤–∏—Ç—å –ø—É—Ç—å –¥–ª—è ${mapType}:`, e);
                            }
                        }
                    });
                    
                    // –ü–æ–º–µ—á–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                    material.needsUpdate = true;
                }
            });
            
            // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –±—É–¥—É—â–∏—Ö –∑–∞–≥—Ä—É–∑–æ–∫ —Ç–µ–∫—Å—Ç—É—Ä
            THREE.DefaultLoadingManager.onLoad = function() {
                console.log('‚úÖ –í—Å–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
                scene.traverse((obj) => {
                    if (obj.isMesh && obj.material) {
                        obj.material.needsUpdate = true;
                    }
                });
            };
            
            THREE.DefaultLoadingManager.onError = function(url) {
                console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É:', url);
            };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–≥–ª—É—à–∫–∏ –º–æ–¥–µ–ª–∏
        function createMockModel() {
            console.log('üì¶ –°–æ–∑–¥–∞—é –∑–∞–≥–ª—É—à–∫—É –º–æ–¥–µ–ª–∏...');
            
            // –°–æ–∑–¥–∞–µ–º –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—É—é –∑–∞–≥–ª—É—à–∫—É
            const group = new THREE.Group();
            
            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1e3a8a,
                shininess: 100 
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            body.castShadow = true;
            group.add(body);
            
            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                shininess: 50 
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            head.castShadow = true;
            group.add(head);
            
            // –®–ª–µ–º
            const helmetGeometry = new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const helmetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1e40af,
                shininess: 150,
                transparent: true,
                opacity: 0.7
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 1.8;
            helmet.rotation.x = Math.PI;
            helmet.castShadow = true;
            group.add(helmet);
            
            // –†—É–∫–∏
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.8, 8);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-0.5, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(0.5, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // –ù–æ–≥–∏
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1, 8);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.2, 0, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.2, 0, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);
            
            model = group;
            scene.add(model);
            
            mixer = new THREE.AnimationMixer(model);
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            console.log('‚úÖ –ó–∞–≥–ª—É—à–∫–∞ –º–æ–¥–µ–ª–∏ —Å–æ–∑–¥–∞–Ω–∞');
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫
        function createButtons() {
            const container = document.getElementById('anim-buttons');
            ANIMATIONS.forEach((anim, index) => {
                const btn = document.createElement('button');
                btn.textContent = anim;
                btn.onclick = () => playAnimation(index);
                container.appendChild(btn);
            });
        }

        // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏
        function playAnimation(index) {
            stopAll();
            currentAnim = index;
            updateButtons();
            isPlaying = true;
            
            const animName = ANIMATIONS[index];
            document.getElementById('current').textContent = animName;
            document.getElementById('status').textContent = '–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ';
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∏–∑ –ø–∞–ø–∫–∏ Anims/
            loadAnimation(animName);
            
            // –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
            startProgress(animName);
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏
        function loadAnimation(name) {
            const loader = new THREE.FBXLoader();
            const path = `Anims/${name}.fbx`;
            
            console.log(`üîÑ –ó–∞–≥—Ä—É–∂–∞—é –∞–Ω–∏–º–∞—Ü–∏—é: ${path}`);
            
            loader.load(path,
                (fbx) => {
                    if (fbx.animations.length > 0 && mixer) {
                        const clip = fbx.animations[0];
                        const action = mixer.clipAction(clip);
                        action.reset();
                        action.setEffectiveTimeScale(1.0);
                        action.play();
                        console.log(`‚úÖ –ê–Ω–∏–º–∞—Ü–∏—è "${name}" –∑–∞–ø—É—â–µ–Ω–∞`);
                    } else {
                        console.warn(`‚ö†Ô∏è –í —Ñ–∞–π–ª–µ ${name}.fbx –Ω–µ—Ç –∞–Ω–∏–º–∞—Ü–∏–π`);
                        simulateAnimation(name);
                    }
                },
                undefined,
                (error) => {
                    console.warn(`‚ö†Ô∏è –ê–Ω–∏–º–∞—Ü–∏—è ${name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —Å–∏–º—É–ª–∏—Ä—É–µ–º...`, error);
                    simulateAnimation(name);
                }
            );
        }

        // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏–π
        function getDuration(name) {
            const durations = {
                'Idle': 3000, 'Up': 2000, 'Fire': 4000,
                'Down': 2000, 'Death': 5000
            };
            return durations[name] || 3000;
        }

        // –°–∏–º—É–ª—è—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
        function simulateAnimation(name) {
            if (!model) return;
            
            const duration = getDuration(name);
            
            // –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∞–Ω–∏–º–∞—Ü–∏–π
            const startRotation = model.rotation.y;
            let targetRotation = startRotation;
            let startPosition = { y: model.position.y };
            let targetPosition = { y: model.position.y };
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∞–Ω–∏–º–∞—Ü–∏–π
            switch(name) {
                case 'Idle':
                    targetRotation = startRotation + Math.PI * 0.1;
                    break;
                case 'Up':
                    targetPosition.y = model.position.y + 0.5;
                    break;
                case 'Fire':
                    targetRotation = startRotation + Math.PI;
                    break;
                case 'Down':
                    targetPosition.y = model.position.y - 0.3;
                    break;
                case 'Death':
                    targetPosition.y = -1;
                    targetRotation = startRotation + Math.PI * 2;
                    break;
            }
            
            const startTime = Date.now();
            
            function animateDemo() {
                if (!isPlaying) return;
                
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                model.rotation.y = startRotation + (targetRotation - startRotation) * easeProgress;
                model.position.y = startPosition.y + (targetPosition.y - startPosition.y) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animateDemo);
                } else {
                    document.getElementById('status').textContent = '–ó–∞–≤–µ—Ä—à–µ–Ω–æ';
                    isPlaying = false;
                    
                    // –ï—Å–ª–∏ –∏–≥—Ä–∞–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                    if (progressTimer) {
                        setTimeout(() => {
                            if (progressTimer) playNextInSequence();
                        }, 500);
                    }
                }
            }
            
            animateDemo();
        }

        // –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
        function startProgress(name) {
            const duration = getDuration(name);
            let startTime = Date.now();
            
            if (progressTimer) clearInterval(progressTimer);
            
            progressTimer = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                
                document.getElementById('progress-bar').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(progressTimer);
                    progressTimer = null;
                }
            }, 50);
        }

        // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        function playSequence() {
            stopAll();
            progressTimer = true;
            playAnimation(0);
        }

        // –°–ª–µ–¥—É—é—â–∞—è –≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        function playNextInSequence() {
            currentAnim++;
            
            if (currentAnim < ANIMATIONS.length) {
                playAnimation(currentAnim);
            } else {
                stopAll();
                progressTimer = null;
                document.getElementById('status').textContent = '–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
            }
        }

        // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å—ë
        function stopAll() {
            isPlaying = false;
            progressTimer = null;
            
            if (mixer) {
                mixer.stopAllAction();
            }
            
            if (model && model.position) {
                model.position.y = 0;
            }
            
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('status').textContent = '–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ';
        }

        // –û–±–Ω–æ–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏
        function updateButtons() {
            const buttons = document.querySelectorAll('#anim-buttons button');
            buttons.forEach((btn, index) => {
                btn.classList.toggle('active', index === currentAnim);
            });
        }

        // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
        function onWindowResize() {
            const canvas = document.getElementById('canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            if (controls) controls.update();
            
            renderer.render(scene, camera);
        }

        // –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (isPlaying) stopAll();
                else playSequence();
            }
            if (e.code === 'ArrowRight') {
                const next = (currentAnim + 1) % ANIMATIONS.length;
                playAnimation(next);
            }
            if (e.code === 'ArrowLeft') {
                const prev = (currentAnim - 1 + ANIMATIONS.length) % ANIMATIONS.length;
                playAnimation(prev);
            }
            if (e.code === 'Escape') {
                stopAll();
            }
        });

        // –ü–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é
        console.log('üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:');
        console.log('   –ü–†–û–ë–ï–õ - –ó–∞–ø—É—Å—Ç–∏—Ç—å/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å');
        console.log('   ‚Üê ‚Üí     - –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–π');
        console.log('   ESC     - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å—ë');
        console.log('   –õ–ö–ú + –¥–≤–∏–∂–µ–Ω–∏–µ - –í—Ä–∞—â–∞—Ç—å –∫–∞–º–µ—Ä—É');
        console.log('   –ö–æ–ª–µ—Å–æ –º—ã—à–∏    - –ü—Ä–∏–±–ª–∏–∑–∏—Ç—å/–æ—Ç–¥–∞–ª–∏—Ç—å');

        // –°—Ç–∞—Ä—Ç
        window.onload = init;
    </script>
</body>
</html>
